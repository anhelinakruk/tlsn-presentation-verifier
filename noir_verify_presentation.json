{"noir_version":"1.0.0-beta.8+ba05d729b9753aa5ce2b076c1dd4795edb173f68","hash":"1698070784709653190","abi":{"parameters":[{"name":"signature_data","type":{"kind":"struct","path":"SignatureData","fields":[{"name":"key","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"message","type":{"kind":"array","length":54,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},"visibility":"private"},{"name":"header_verification","type":{"kind":"struct","path":"HeaderVerification","fields":[{"name":"header_root","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"verifying_key_data","type":{"kind":"array","length":35,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"connection_info_data","type":{"kind":"array","length":17,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"server_ephemeral_key_data","type":{"kind":"array","length":67,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"cert_commitment_data","type":{"kind":"array","length":34,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"transcript_commitments_data","type":{"kind":"array","length":83,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},"visibility":"private"},{"name":"commitment_verification","type":{"kind":"struct","path":"CommitmentVerification","fields":[{"name":"commitment_root","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},"visibility":"private"},{"name":"transcript_currency","type":{"kind":"struct","path":"TranscriptOpeningCurrency","fields":[{"name":"direction","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"data","type":{"kind":"array","length":16,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"blinder","type":{"kind":"array","length":16,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"position","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"public"},{"name":"transcript_comment","type":{"kind":"struct","path":"TranscriptOpeningComment","fields":[{"name":"direction","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"data","type":{"kind":"array","length":23,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"blinder","type":{"kind":"array","length":16,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"position","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"public"},{"name":"transcript_amount","type":{"kind":"struct","path":"TranscriptOpeningAmount","fields":[{"name":"direction","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"data","type":{"kind":"array","length":11,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"blinder","type":{"kind":"array","length":16,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"position","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"public"},{"name":"transcript_user_name","type":{"kind":"struct","path":"TranscriptOpeningUserName","fields":[{"name":"direction","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"data","type":{"kind":"array","length":23,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"blinder","type":{"kind":"array","length":16,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"position","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"public"},{"name":"encoder_secret","type":{"kind":"struct","path":"chacha_encoder::chacha_encoder::EncoderSecret","fields":[{"name":"seed","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"delta","type":{"kind":"array","length":16,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},"visibility":"private"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6668324276689745315":{"error_kind":"string","string":"Field failed to decompose into specified 4 limbs"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+1dBZjVVrfNKDO4FistpbSlQrkZH4oM7u7OKK4tdZm6u7tBoVSou7u7u1AvNer69u4kzJqwkvK/Ock/ea/3+xZ3zcrOyT4755zkJudskqyqz/JU+Se1iicJUpxv/WR4tCSiJRMthWipREsjWjrR6hEtg2iZRKtPtAZEa0i0RkRrTLQmRGtKtGZEa060FkRrSbRWRNuKaK2J1oZobYnWjmjtibY10ToQbRuibUu0jkTbjmidiLY90ToTbQei7Ui0nYjWhWg7E20Xou1KtN2I1pVouxOtG9ESRLOJlkW0bKLlEC2XaHlEyydaAdEKidadaHsQrQfRehKtF9F6E62IaH2I1pdo/YjWn2gDiDaQaIOINphoQ4g2lGjDiDacaCOINpJoo4g2mmhjiDaWaOOINp5oE4g2kWiTiDaZaFOINpVo04g2nWgziDaTaLOINptoxUQrIVop0cqIVk60CqLNIdpcos0j2nyiLSDaQqItItpioi0h2lKiLSPacqLtSbS9iLaCaHsTbR+i7Uu0/Yi2P9EOINqBRDuIaAcT7RCiVRLtUKIdRrTDiXYE0Y4k2lFEO5poxxDtWKIdR7TjiXYC0U4k2klEO5lopxDtVKKdRrTTiXYG0c4k2llEO5to5xDtXKKdR7TziXYB0S4k2kVEu5holxDtUqJdRrTLibaSaKuIdgXRVhNtDdGuJNpaol1FtKuJdg3RriXaOqJdR7TriXYD0W4k2k1Eu5lotxDtVqLdRrTbiXYH0e4k2l1Eu5to9xDtXqLdR7T7ifYA0R4k2kNEe5hojxDtUaI9RrTHifYE0Z4k2lNEe5pozxDtWaI9R7TnifYC0V4k2ktEe5lorxDtVaK9RrTXifYG0d4k2ltEe5to7xDtXaK9R7T3ifYB0T4k2nqifUS0j4n2CdE+JdpnRPucaF8Q7UuibSDaV0T7mmjfEO1bon1HtI1E+55oPxDtR6L9RLSfifYL0X4l2m9E+51ofxDtT6L9RTT9x6slES2ZaClESyVaGtHSiVaPaBlEyyRafaI1IFpDojUiWmOiNSFaU6I1I1pzorUgWkuitSLaVkRrTbQ2RGtLtHZEa0+0rYnWgWjbEG1bonUk2nZE60S07YnWmWg7EG1Hou1EtC5E25louxBtV6LtRrSuRNudaN2IliCaTbQsomUTLYdouUTLI1o+0QqIVki07kTbg2g9iNaTaL2I1ptoRUTrQ7S+ROtHtP5EG0C0gUQbRLTBRBtCtKFEG0a04UQbQbSRRBtFtNFEG0O0sUQbR7TxRJtAtIlEm0S0yUSbQrSpRJtGtOlEm0G0mUSbRbTZRCsmWgnRSolWRrRyolUQbQ7R5hJtHtHmE20B0RYSbRHRFhNtCdGWEm0Z0ZYTbU+i7UW0FUTbm2j7EG1fou1HtP2JdgDRDiTaQUQ7mGiHEK2SaIcS7TCiHU60I4h2JNGOItrRRDuGaMcS7TiiHU+0E4h2ItFOItrJRDuFaKcS7TSinU60M4h2JtHOItrZRDuHaOcS7TyinU+0C4h2IdEuItrFRLuEaJcS7TKiXU60lURbRbQriLaaaGuIdiXR1hLtKqJdTbRriHYt0dYR7TqiXU+0G4h2I9FuItrNRLuFaLcS7Tai3U60O4h2J9HuItrdRLuHaPcS7T6i3U+0B4j2INEeItrDRHuEaI8S7TGiPU60J4j2JNGeItrTRHuGaM8S7TmiPU+0F4j2ItFeItrLRHuFaK8S7TWivU60N4j2JtHeItrbRHuHaO8S7T2ivU+0D4j2IdHWE+0jon1MtE+I9inRPiPa50T7gmhfEm0D0b4i2tdE+4Zo3xLtO6JtJNr3RPuBaD8S7Sei/Uy0X4j2K9F+I9rvRPuDaH8S7S+i6cQ+r5ZEtGSipYjW0aOlErs0oqUTrR7RMoiWSbT6RGtAtIZEa0S0xkRrQrSmRGtGtOZEa0G0lkRrRbStiNaaaG2I1pZo7YjWnmhbE60D0bYh2rZE60i07YjWiWjbE60z0XYg2o5E24loXYi2M9F2IdquRNuN9JmuxG53onUjWoJoNtGyiJZNtByi5RItj2j5RCsgWiHRuhNtD6L1IFpPovUiWm+iFRGtD9H6Eq0f0foTbQDRBhJtENEGE20IaUNDid0wog0n2giijSTaKKKNJtoYoo0l2jiijSfaBKJNJNokok0m2hSiTSXaNKJNJ9oMos0k2iyizSZaMdFKiFZKtDKilROtgmhziDaXaPOINp9oC4i2kGiLiLaYaEuItpRoy4i2nPSZPYndXkRbQbS9ibYP0fYl2n5E259oBxDtQKIdRLSDiXYI0SqJdijRDiPa4UQ7gmhHEu0ooh1NtGOIdizRjiPa8UQ7gWgnEu0kop1MtFOIdirRTiPa6UQ7g2hnEu0sop1NtHOIdi7RziPa+US7gGgXEu0iol1MtEuIdinRLnM0ZwnT37rlbMuzan6SnO8i5ztRu49dZK6sRFg+9omBj31j4GO/GPjYPwY+DoiBjwNj4OOgGPg4OAY+DomBj0Nj4OOwGPg4PAY+joiBjyNj4OOoGPg4OgY+jomBj2Nj4OO4GPg4PgY+ToiBjxNj4OOkGPg4OQY+TomBj1Nj4OO0GPg4PQY+zoiBjzNj4OOsGPg4OwY+FsfAx5IY+FgaAx/LYuBjeQx8rIiBj3Ni4OPcGPg4LwY+zo+Bjwti4OPCGPi4KAY+Lo6Bj0ti4OPSGPi4LAY+Lo+Bj3vGwMe9YuDjihB8xI+ZsrPzwis7oVOLN8W2qcMvF3GlYJXgCsFqwRrBlYK1gqsEVwuuEVwrWCe4TnC94AanwBuTrZqTe7TQjh5tJdFWEe0Koq0m2hqiXUm0tUS7imhXE+0aol1LtHVEu45oNzoaflJMnmQ7kSiyzHWaPlBWdiIvJ6c8P6vczraLE1mFJQW5iZzckrwCu8DOLcgtyyrIzi4vyCnILywpzE8U2jnZ5XZFbmF2hVPYTcnmGjLG9CYS02TDMUXfaxuHm0OKw81hty2zE77smw3G9JaQYnpLBG3rFoNxuDWkONwaQdsyOFHPvtVgTG8LKaa3hd22JA6X19E4hNaOpD8ZnExZY9JjbeN3e0jt6PYIxqjbDbajO0KKwx0RjFEGJ5jadxiM6Z0hxfTOCNrWnQbjcFdIcbgrgrZlcGKwfZfBmN4dUkzvjuD6t7KOxiG0diT9yeDk7RqTrGsbv3tCakf3RDBG3WOwHd0bUhzujWCMMjih3b7XYEzvCymm90XQtu4zGIf7Q4rD/RG0LYMLEez7Dcb0gZBi+kAE179VdTQOobUj6U8GF4vUWNRR2/g9GFI7ejCCMepBg+3ooZDi8FAEY5TBBTT2QwZj+nBIMX04grb1sME4PBJSHB6JoG0ZXPhkP2Iwpo+GFNNHI7j+XVFH4xBaO5L+NNpg/HARWW3j91hI7eixCMaoxwy2o8dDisPjEYxRBhfs2Y8bjOkTIcX0iQja1hMG4/BkSHF4MoK2ZXChpf2kwZg+FVJMn4rg+re6jsYhtHYk/cngYtgai1ZrG7+nQ2pHT0cwRj1tsB09E1IcnolgjDK4QNh+xmBMnw0pps9G0LaeNRiH50KKw3MRtC2DC7vt5wzG9PmQYvp8BNe/NXU0DqG1I+lPBhff11gkX9v4vRBSO3ohgjHqBYPt6MWQ4vBiBGOUwYQE9osGY/pSSDF9KYK29ZLBOLwcUhxejqBtGUwkYb9sMKavhBTTVyK4/l1ZR+MQWjuS/mQw2UeNpBy1jd+rIbWjVyMYo1412I5eCykOr0UwRhlMgGK/ZjCmr4cU09cjaFuvG4zDGyHF4Y0I2pbBxDX2GwZj+mZIMX0zguvf2joah9DakfSn2QbjV2yZi99bIbWjtyIYo94y2I7eDikOb0cwRpUYLOttgzF9J6SYvhNB23rHYBzeDSkO70bQtkoNlvWuwZi+F1JM34vg+ndVHY1DaO1I+pPBZGY1ko7VNn7vh9SO3o9gjHrfYDv6IKQ4fBDBGGUwwZv9gcGYfhhSTD+MoG19aDAO60OKw/oI2pbBxHz2eoMx/SikmH4UwfXv6joah9DakfQng8kTayQ5rG38Pg6pHX0cwRj1scF29ElIcfgkgjHKYEJJ+xODMf00pJh+GkHb+tRgHD4LKQ6fRdC2DCYCtT8zGNPPQ4rp5xFc/66po3EIrR1JfzKYrLVGUtXaxu+LkNrRFxGMUV8YbEdfhhSHLyMYowwmsLW/NBjTDSHFdEMEbWuDwTh8FVIcvoqgbRlMPGx/ZTCmX4cU068juP5dW0fjEFo7kv5kMDl0jSTOtY3fNyG1o28iGKO+MdiOvg0pDt9GMEYZTJhtf2swpt+FFNPvImhb3xmMw8aQ4rAxgrZlMNG5vdFgTL8PKabfR3D9W1dH4xBaO5L+ZDAZfY2k8bWN3w8htaMfIhijfjDYjn4MKQ4/RhCHHw3G4aeQ4vBTBOPKdXU0DqlOXZOtzT9JIcYgUcsPcddE2bb+g7H42fnjl2Sr5n9MoBuaehwwfYE30WjKKyq03dg/G2yAv4R0Ik03uLj4eX1M/Lzh34EnsoHnV+eP37wDz6/OwIPabzEbjH41OBj9FlHnqa2fv4fkp8E7lb8boclz80dId2x/RHDH9ofBOPxpKA4Fnjj86cQh1aoeD9y26x0PTA+ql4fQnk37uDIGPq6KgY9XxMDH1THwcU0MfLwyBj6ujYGPV8XAx6tj4OM1MfDx2hj4uC4GPv4Zgo+WWR8jK9dc2dn5IZadlwRtwb3n/EtvxuVmNEmQLEgRpArSBOmCeoIMQaagvqCBoKGgkaCxe3Prfv/l3OSipsSrJREtmWgpREslWhrR0olWj2gZRMskWn2iNSBaQ6I1IlrjlOofBFE9XVHfDJUVXiewaz5daeL8UmrqbWy6oY3HAdNPUjBgtXmSIs9S7CYGynJ/pTYN6USabnAm/Yyyo4R5dTPip131hbFo5jT+5t6OohsyPFrzCDrPn0YeQ1aV1cxg52keUucx+lhLTrDJOrcwWGdsRy3+C1exOt85yTuClk7nauXtnLrB+46gVUr47wjMdM6qdwQtDTbUVjG9YrSM4a3VVk6jau1tlFs5VwfUWjtXkTAbpYmG5N5ubWWwUbYO6eSajp/BUd5ubTB+bUK6+rRxrj74MX0VbmMwDm1DikPbf6/CPl7WHPDaOR2uvXfAa0cGvPYRDHimrsI64LUz2FDbx/Qq3C6GV+GtnUbVwdsotyaNskMEjbKdwavw1gYbZYeYXIUNjvJ2B4Px2yakq882EVyFtzEYh21DisO2YcfB0APJMOIQVOfa+mlw+or9V3I86mxwOoxtxeQ8G5xeYyfFpM4Gp+vYyTGps8HpP3ZKTOpscDqRnRqTOhucnmSnxaTOBqc72ekxqbPB6VN2vZjU2eB0LDsjJnU2OL3LzoxJnQ1OF7Prx6TOBqef2Q3q9rtW2yWNDP6u6hjS70ss13Ac3I/d2OCzi46mniOV59pYZ9PLfToZqHNecaKwPC8vP0w/tzfgZ0lJXn5xeUFumH52NuBndmleeUV2flaYfu5gwM/i3JyKitzs4jD93NGAn7l2ojw3K78iTD93MuBnYUkiN6+goDRMP7sY8NOuKMguKywuCdPPnU2c95LyRGmZXfj3XB3HR32e1tHhK4GvAn4F8NXA1wC/Evha4FcBvxr4NcCvBb4OOM6exVmzjYF3Ar498M7AdwC+I/CdgHcBvrPDd5HvXQW7CboKdhd0EyQEdkrVG9YUq/qdQdD5T9TuY+8Sh5dZiUROaGXbVfc/bmxTHZ4lcckW5AhyvS/NslI2n+yYTbQcouWmbP5yLc1ssGqc1NoOEFkGX9RlGypL65hjpKyqeOUafhMdVefd9d/OSztvnsQlX1AgKPR23jzSKfOJVkC0wgg6764GO2+ewc6bb7DzFhjsvIUx7by7/dt5aeftLnHZQ9BD0NPbebuTTrkH0XoQrWcEnXc3g523u8HOu4fBztvDYOftGdPO2/Xfzks7by+JS2+NjaCPt/P2Ip2yN9GKiNYngs7b1WDn7WWw8/Y22HmLDHbePjHtvLv/23lp5+0rcekn6C8Y4O28fUmn7Ee0/kQbEEHn3d1g5+1rsPP2M9h5+xvsvANi2nm7/dt5aecdKHEZJBgsGOLtvANJpxxEtMFEGxJB5+1msPMONNh5BxnsvIMNdt4hMe28iX87L+28QyUuwwTDBSO8nXco6ZTDiDacaCMi6LwJg513qMHOO8xg5x1usPOOiGnntf/tvLTzjpS4jBKMFozxdt6RpFOOItpooo2JoPPaBjvvSIOdd5TBzjvaYOcdY7AT6DlOt6o7qnv+k4AnWzXbRQY0PpenAU8HXg94BvBM4PWBNwDeEHgj4I2BNwHeFHgz4M2BtwDeEngr4FsBbw28DfC2wNsBbw98a+AdgG8DfFvgHYFvB7wT8O2Bdwa+A/Adge8EvAvwnYHvAnxX4LsB7wp8d+DdgCeA28CzgGcDzwGeCzwPeD7wAuCFwLsD3wN4D+A9gfcC3hv43sD3Ab4v8P2A7w/8AOAHAj8I+MHADwFeCfxQ4IcBPxz4EcCPBH4U8KOBHwP8WODHAT8e+AnATwR+EvCTgZ8C/FTgpwE/HfgZwM8Efhbws4GfA/xc4OcBPx/4BcAvBH4R8IuBXwL8UuCXAb8c+Ergq4BfAXw18DXArwS+FvhVwK8Gfg3wa4GvA34d8OuB3wD8RuA3Ab8ZeC5c/3HaCE4rwWknhcDxTTW+yc4D3hM4vhzDl2f4cq0PcHwej8/r8Xn+AOD4CBAfEeIjxCHA8akDPpXApxYjgOMPHfwhhD+UxgDHeyu893LvzcZ67p6TnO8i5ztRu4891uA9lvqm1/ts8NeMn8XlGUbLK802W15+mdnycnLNlldSaLa8wlLD9TV8fnNKzJaXZ7q95JstL5FnuL3YZssrN9z+8gvMllds+PyWl7jj+CtW9Zj+KvDXgL8O/A3gbwJ/C/jbwN8B/i7w94C/D/wD4B8CXw/8I+AfA/8E+KfAPwP+OfAvgH8JfAPwr4B/Dfwb4N8C/w74RuDfA/8B+I/AfwL+s8PHyfVvvGCCYKJgkmCyYIpgqmCaYLpghmCmYJZgtqBYUCIoFZQJygUVgjmCuYJ5gvmCBYKFgkWCxYIlgqWCZYLlKVW+6DVzO6v6U+R8J2r1KTR8TcpLGO7Dpq9JWWbLyzY8RucbviaV5ZgtzzY85pcYHlMLDd8j5FWYLa/AdP8w3P6yTV+DDZ/fRJY7Nv9iVY/TvwL/DfjvwP8A/ifwv4DrPy5PAp4MPAV4KvA04OnA6wHPAJ7p8D1lfN9LsEKwt2Afwb6C/QT7Cw4QHCg4SHCw4BBBpeBQwWGCwwVHCI4UHCU4WnCM4FjBcYLjBScIThScJDhZcIrgVMFpcG0ZZ1V/isz0HcN9sczw2J0wfb9u+H6zxPDvp2zDY0+Z6ft/07/vDF/7ik1fSw23l1zD14ICw+UVG77XLDY8HpTnumNzfRinGwBvCLwR8MbAmwBvCrwZ8ObAWwBvCbwV8K2AtwbeBnhb4O2Atwe+NfAOwLcBvi3wjsC3A94J+PbAOwPfAfiOwHcC3gX4zsB3Ab4r8N2AdwW+O/BuwBPAbeBZwLOB5wDPBZ4HPB94AfBC4N2B7wG8B/CewHsB7w28CHgf4H2B9wPeH/gA4AOBDwI+GPgQ4EOBDwM+3OGny33DGYIzBWcJzhacIzhXcJ7gfMEFggsFFwkuFlwiuFRwmeBywUrBKsEVgtWCNYIrBWsFVwmuFlwjuFawTnCd4HrBDXDPgokPipzvRK0+ZYavkRWGx1Db9O8Hw79vyg3/fs03fE9Qbvieyjbsn+lreKHhe1zT9+Dlpp/RGvavxPAz80LD5VUk3LF5BIzTI4GPAj4a+BjgY4GPAz4e+ATgE4FPAj4Z+BTgU4FPAz4d+AzgM4HPAj4beDHwEuClwMuAlwOvAD4H+Fzg84DPB74A+ELgi4AvdviNcq26SXCz4BbBrYLbBLcL7hDcKbhLcLfgHsG9gvsE9wseEDwoeEjwsOARwaOCxwSPC54QPCl4SvC04BnBs4LnBM8LXoDrZKlV/Sky0u5sw+3YNv3c07B/uYZ/6xYbfnebMHxdKzHsX4Xh66Rt+rmn4fugPMPPUSsMX9dyDZ9f03MvSgyXVzUXQcfDJTBOLwW+DPhy4HsC3wv4CuB7A98H+L7A9wO+P/ADgB8I/CDgBwM/BHgl8EOBHwb8cOBHAD8S+FHAjwZ+DPBjgR8H/HjgJwA/EfhJwE8GfgrwU4GfBvx04GcAPxP4WcDPBn4O8HOBnwf8fOAXAL8Q+EXALwZ+CfBLgV8G/HLgK4GvAn4F8NXA1wC/Evha4FcBvxr4NcCvBb4O+HXArwd+A/Abgd8E/GbgtwC/FfhtwG8HfgfwO4HfBfxu4PcAvxf4fcDvd/iLct/zkuBlwSuCVwWvCV4XvCF4U/CW4G3BO4J3Be8J3hd8IPhQsF7wkeBjwSeCTwWfCT4XfCH4UrBB8JXga8E3gm8F38E9V5FV9dG/df6A6+d44BOATwQ+Cfhk4FOATwU+Dfh04DOAzwQ+C/hs4MXAS4CXAi8DXg68Avgc4HOBzwM+H/gC4AuBLwK+GPgS4EuBLwO+HPiewPcCvgL43sD3Ab4v8P2A7w/8AOAHAj8I+MHADwFeCfxQ4IcBPxz4EcCPBH4U8KOBHwP8WODHAT8e+AnATwR+EvCTgZ8C/FTgpzl8o3x/L/hB8KPgJ8HPgl8Evwp+E/wu+EPwp+AvgS4OSRIkC1IEqYI0QbqgniBDkCmoL2ggaChoJGgsaCJoKmgmaJ7K++Pp4OcZwM8Efhbws4GfA/xc4OcBPx/4BcAvBH4R8IuBXwL8UuCXAb8c+Ergq4BfAXw18DXArwS+FvhVwK8Gfg3wa4GvA34d8OuB3wD8RuA3Ab8Z+C3AbwV+G/Dbgd8B/E7gdwG/G/g9wO8Ffh/w+4E/APxB4A8Bfxj4I8AfBf4Y8MeBPwH8SeBPAX8a+DPAnwX+HPDngb/g8BbSJ1oKWgm2ErQWtBG0FbQTtBdsLegg2EawraCjYDtBJ8H2gs6CHQQ7CnYSdBHsLNhFsKtgN0FXwe6CbgJd5WkLsnz640bw83vgPwD/EfhPwH8G/gvwX4H/Bvx34H8A/xP4X8B1LHJ5EvBk4CnAU4GnAU8HXg94BvBM4PWBNwDeEHgj4I2BNwHeFHgz4M2BtwDeEngr4FsBbw28DfC2wNsBbw98a+AdgG8DfFvgHYFvB7wT8O2Bdwa+A/Adge8EvAvwnYHvAnxX4LsB7wp8d+DdgCeA28CzHJ4t3zmCXEGeIF9QICgUdBfsIegh6CnoJegtKBL0EfQV9BP0FwwQDBQMEgwWDBEMFQwTDBeMEIwUjBKMFowRjPXpj9ngZw7wXOB5wPOBFwAvBN4d+B7AewDvCbwX8N7Ai4D3Ad4XeD/g/YEPAD4Q+CDgg4EPAT4U+DDgw4GPAD4S+Cjgo4GPAT4W+Isw/rwE/GXgrwB/FfhrwF8H/gbwN4G/Bfxt4O8Afxf4e8DfB/4B8A+Brwf+EfCPgX8C/FPgnwH/HPgXwL8EvgH4V8C/Bv4N8G+Bf+fwcXIexgsmCCYKJgkmC6YIpgqmCaYLZghmCmYJZguKBSWCUkGZoFxQIZgjmCuYJ5gvWCBYKFgkWCxYIlgqWCZYLsBPsvNd5HzXdu3VLZa5NWEaJ0Nlhfr/tNxqsM7jY1Ln2wzWeUJM6ny7wTpPjEmd7zBY50kxqfOdBus8OSZ1vstgnafEpM53G6zz1JjU+R6DdZ4Wkzrfa7DO02NS5/sM1nlGTOp8v8E6z4xJnR8wWOdZManzgwbrPDsmdX7IYJ2LY1Lnhw3WuSQmdX7EYJ1LY1LnRw3WuSwmdX7MYJ3LY1Lnxw3WuSImdX7CYJ3nxKTOTxqs89yY1Pkpg3WeF5M6P22wzvNjUudnDNZ5QUzq/KzBOi+MSZ2fM1jnRTGp8/MG67w4JnV+wWCdl8Skzi8arPPSmNT5JYN1XhaTOr9ssM7LDdb57zlMTlnNk6vrn+TEwJme+fecEc3V7ebo1pzcmotbc3Br7m3Nua25tjXHtubW1pzamktbc2hr7mzNma25sjVHtubG1pzYmgtbc2Br7mvNea25rjXHdUerKvdZJ6sqh3Vnqypnteaq1hzVXayqnNSai1pzUGvuac05rbmmNce0nkjNKa3rxTXvqOaO1pzRmitac0RrbmjNCa25oDUHtOZ+1pzPmuu5t3Oe+gj6CvoJ+gsGCAYKBgkGC4YIhgqGCYYLRghGCkYJRgvGCMZaVXl2xgsmCCYKJgkmC6YIpgqmCaYLZghmCmYJZguKBSVW1Vq+MkG5QP+j+jmCuYJ5gvmCBYKFgkWCxYIlgqWCZYLlgj0FewlWWFU5qzVXteao1tzUmpNac1FrDmrNPa05pzXXdKVVlVv6MKsql/QRVlXuaM0Zrbmij7GqckNrTmjNBa05oDX3s+Z81lzPmuNZcztrTmfN5aw5nDV3s+Zs1lzNmqNZczNrTmbNxaw5mDX3suZc1lzLl1hVuZUvs6pyKa+0qnIna85kzZW8xqrKjaw5kTUXsuZA1tzHmvNYcx1rjmPNbaw5jTWXseYw1tzFOh9C5wfo+3J9f6zvU/X9or5v0/dP+j5G30/cJ9Dn1w8I9PmmPu/T51/6PEifj+jzAv39rL8n9feV/t7Q+2+9H9X7M71f0eu3Xs90fNfxTvu/5n3UfI+a51HzO2peR83nqHkcNX+j5m3UfI3vWVX5GT+wqvIxrreq8i9q3kXNt/ipVZVfUfMqaj5FzaOo+RM1b6LmS9Q8iZofUfMiaj5EzYOo+Q8176HmO9Q8h5pPS/Noaf4szZul+bI0T5bmx9LOr/mwNA+W5r/SvFea70rzXP2d3yqpKp+V5k3RfCmaJ0Xzo2heFM2HonlQNP+J5j3RfCea50Tzm2heE81nonlMNH+J5i3RfCWap0Tzk2heEs1H0jGpKv+I5h3RfCOaZ0Tzi2heEc0nonlENH+I5g3RfCGaJ0Tzg2heEM0HooOa5v/QvB+a70PzfGh+D83rofk8NI+H5u/QvB2ar0PzdGh+Ds3Lofk4ipKq8m9o3g3Nt6F5NjS/hubV0HwamkdD82do3gzNl6F5MnQ9tq7D1vXXuu5a11vrOmtdX63rqnU9ta6j1vXTum5a10vrOmldH63ronU9tK6D1vXPs5Oq1jvrOmdd36zrmnU9s65j1vXLum5Z1yvrOmVdn6zrknU9sq5D1vVuus5N17fpujZdz6br2HT9mq5b0/Vquk5N16fpujRdj6br0HT9ma470/VmlUlV68t0XZmuJ9N1ZLp+TNeN6XoxXSem68N0XZiuB9N1YLr+S9d96XovXeel67t0XZeu59J1XLp+S9dt6XotXael67N0XZaux9J1WLr+Stdd6XqrS5Kq1lfpuipdT6XrqHT9lK6b0vVSuk5K10fpuihdD6XroHT9k6570vVOus5J1zfpuiZdz6TrmHT9kq5b0vVKuk5J1yfpuiRdj6TrkHT9ka470vVG9yVVrS96QPCg4CHBw4JHBI8KHhM8LnhC8KTgKcHTgmcEzwqeEzwveEHwouAlwcuCVwSvCl4TvC54Q/Cm4C3B24J3BO8K3hO8r+dOLsB7CVYI9hbsI9hXsJ9gf8EBggMFBwkOFhwiqBQcKjhMcLjgCMGRgqMERwuOERwrOE5wvOAEwYmCkwQnC04RnCo4TXC64AzBmYKzBGcLzhGcKzhPcL7gAsGFgosEFwsuEVwquCy56hqgnw+kLh8K1gs+Enws+ETwqeAzweeCLwRfCjYIvhJ8LfhG8K3gO8FGwfeCHwQ/Cn4S/Cz4RfCr4DfB74I/BH8K/hLoDUySIFmQIkgVpAnSBfUEGYJMQX1BA0FDQSNBY0ETQVNBs+Sq+6IWgpaCVoKtBK0FbQRtBe0E7QVbCzoIthFsK+go2E7QSbC9oLNgB8GOgp0EXQQ7C3YR7CrYTdBVsLugmyAhsAVZgmxBjiBXkCfIFxQICgXdBXsIegh6CnoJeguKBH0EfQX9BP0FAwQDBYMEgwVDBEMFwwTDBSMEIwWjBKMFYwRjBeME4wUTBBMFkwSTBVMEUwXTBNMFMwQzBbMEswXFghJBqaBMUC6oEMwRzBXME8wXLBAsFCwSLBYsESwVLBMsT7Y2fcZXU+smR2+1vk/bZU+sHgCbrFucbU+e8ewja44pLsNttwXsd0fAfncF7HdvwLb7A8p8MGC/hwP2ezRgvycCtj0VUOYzAfs9F7DfCwH7vRyw7dWAMl8P2O/NgP3eDtjvvYBtHwSUuT5gv48D9vs0YL8vArZtCCjz64D9vg3Yb2PAfj8GbPs5oMxfA/b7PWC/PwP2S0rx35aS4l9mWsB+9QL2ywzYr2HAtsYBZTYN2K95wH4tA/ZrHbCtbUCZ7QP26xCw37YB+3UK2NY5oMwdA/brErDfLgH7dQ3Y1i2gTDtgv+yA/XID9isI2NY9oMweAfv1CtivKGC/fgHbBgSUOShg24SAbZMCjrc8YL8DA/Y7OGC/YwL2Oy5gv/MCtq11tl1+c86Sc1cdNx23XRew7ZaAbXcFbHsgYNtjAdueCdj2ks829xmf/lbXT6bzt3trpbLuWuT8najdx86Eck2XX5AoqMi0an4M+5+d6ZSZGkr52QVu+Wnh+J+o55QzsLK6fKyLe9wUj513nySwGQQ2g3xsBoPNYB+bIWAzxMdmKNgM9bEZBjbDfGyGg81wH5sRYDPCx2Yk2Iz0sRkFNqN8bEaDzWgfmzFgM8bHZizYjPWxGQc243xsxoPNeB+bCWAzwcdmIthM9LGZBDaTfGwmg81kH5spYDPFx2Yq2Ez1sZkGNtN8bKaDzXQfmxlgM8PHZibYzPSxmQU2s3xsZoPNbB+bYrAp9rEpAZsSH5tSsCn1sSkDmzIfm3KwKfexqQCbCh+bOWAzx8dmLtjM9bGZBzbzfGzmg818H5sFYLPAx2Yh2Cz0sVkENot8bBaDzWIfmyVgs8THZinYLPWxWQY2y3xsloPNch+bPcFmTx+bvcBmLx+bFWCzwsdmb7DZ28dmH7DZx8dmX7DZ18dmP7DZz8dmf7DZ38fmALA5wMfmQLA5EGxSwOYgsDnIY5MJZaJe5PydqMWnIJGTF+59THZeI6vmvYsFdXGPnR7OsfOTPMezrOqY4zb3+PWtze+zTN5TJ3mO5/rjjY97T9/Itams9ifJsy21cvN6uNvSYJt7fvXd/xSw87atVM82eHS7qf02smq2cf247VbLL4NjzbVq+o77pHiOb8Hxwrx/L0jkl4fb7u0EO3cpEFv9pMK2VM+2LTl3+jkJ7LyxSwk5duH0E9tuQfzHY+mnXqW16ZPiiTXGz41TBtp7tmXCttTKmsep7/ydCsfBslw/0jz2pc7fTZzvdNjH3b8pOX665/g1/CYa/v73lpVCNNdexwr34YLOAXJ/j/errC7P3DnNSbjl9w+l/ESOW/6AUMq3Exoj7X/r3ZhaYY4fiYQ7xuK1wnvdrBfKsW17S6+b7vHrW2Fex6uvm/U8/njj4x3/MsKJTyLJUz76k0Hi457LTLLNLau+83calIX2GVBHtEfu7o/avs53U1JmmseHTFIf1HDsWO6pG56bJJ9vt1yvluzxEWOT7vExHerp+uh9BupuR/uTwfeDPWWy84j3KTgmYkzSiT2Wl+axP8z51u2fW7xMv3r5lXk0+HKkw9nY4dZBtRMtXv8kKzimW1r/ZB9fj4f6b/DxFf1BX72/I3Af/T41wC6N2Hnbk2Xxe/H+lTXtM0jdmU9pHvszreq6u+c+3HGqetzM9JTvF2/vWIR1zAioo2t/HtRxg6dMd58Ui48t/StrxsT7/qHIUEwyrc3HT5O/d93yG3jqb8j/hFt+w3DKL/D+7vP2n0s9x930e8XiY4e3rbj2q6HMlQ5vAuW6+3uvoVi22+8awPbGVvWnttehxmDjvVY2gX289dZP/8qa9s3guCmeMpi9+9sgFeybgQ/eMda1X+d8ax/8xuFubBqR+mj8r7f4sfGcuvuir95jPwRl3uTwJuTYjT3bMM7e+6ImxBeM84DKmr649rc73xqHjQ5nv8ndY7vjTSpsM3lPrX78CH54z39aZc16N4VtrL1gP8C2gfZNwcbbtrEtNfJsw3PQxHOcRuQ47D6F9Vd3XzaONAuor7f9KJpDWczeLS/NY/+Y883uwZrDPqzPpfqU+TT48qSn/ngOGoDd6z7HxvqnkPq49i1I/dG+ucdX1/75gPo3I/VvDjb1PWW69i9BmRt9/MR6sTHX1VsS+xakXk2szePi7sti79ph7FkZjT3+uMerb/E20dDjK27D42PdWd9uTnwNOtfNyXG85/o95xvPNbu2NfUcj/mH/c/bxxuRsvC6EubYml9QtQbub18rq+OAv98sz/HTPPafOX/jPaH7nVoLPyvyi+2K7OKK4tzisrKc0uLmnvL147b/BiEcPye3OL+0ON+2C3Ps8hw7N+rjZxUU5BVmlSRy8stKK8pysqM+fl5Onl1QUFxQmldaUZhTWhL18Utz80pK5SQkyu2/w/FPx2fPivFeRT/u82Z8Ho32eF+I9r+6tlbVejH9eN814PHUrkGSv12Sz/ffZRAttbKmxp5T4/N71949dv3KzX10tzWAbXgfpZ+Gzt8YLyzL9SPNY5/hFOCeE3zm7u7flBw/w3P8Gn4Tzfv8vgGxb0Ds9fwkOTttui7DsU0/R/j7mJ7yUfP65rYdbdctHR7vOYt5hfGes2hnRTVncVBldflBcxZdO+8+KWDjNx8RbfzmI6KN33xEtPGbj4g2fvMR0cZvPiLa+M1HRBu/+Yho4zcfEW385iOijd98RLTxm4+INn7zEdHGbz4i2vjNR0Qbv/mIaOM3H1G3hzy3Jj+KOQbYxyyoS7hza7b8HeH/t7k1WWDnbVtBc2vc9svm1rjtVsvvCcfqa9X0HcsL+q0d7vyQ3MKQr2N0bo33vKZW1jw2bsNzlwrxzPLEJ4z7FIxPGPHX+LTw8d/l+nF/F1gWv/92Y/Tfmj/Tw/m7Ls+fyXV4+PNnque39A+lfDsR7vyZRLlb/sAwypef1+78HPdZTtC1cUuuXfrxPjPH8SzJc5w0g8fB+wXvmB3OnJ9EjlunDPCTPd/3vp/B33TsXbHX3ns/4i0/M5r6bjaHB9+zpRP//xvvpZPMlV/gnY/gzhXRuo7zHNN9T8HagH6882Eaes6R18Y7hwffA3ljjvt63xlPdr61Dl97ymTzghpAmf09Zbr206DM73z8tKzg+ylXb0zs8dm4608Ta/O4NPbsh8/nve/6Wdlon+JTjvcdmreeyaDVJ2W7bdT7vqDI+TtRy49bnnvNT4VjNCX+eN/5zvP41dwT06CYKZqR427J+y/3uNqGfvCU6frWwOLjy6Z7KIv3lSLn70TtPjneOKZZm7dbbz9C+6XOt25f7HD32sfGe7Xbx1MX/C0Y9I430+Lnp8hILLI2a2cYC9Y+vO1shfOt9f45IBbpJBZBvzujmIPwm8dfHHfTPD6x8Y/Nt/1Pxz/2DjLDs43NqcMxy3sc9MU7XuJ5YPZued5rw+HOt/rWLKmmf2lkf5yD2YQcx7sPPg8Nus6G+XtUGwZ7VoHzg47z8RuvtXhOBlRWb0f7N6DME62adUsKp24FXp+Tic/uMdGfsO873TaG9531iD/eNnmWVfNcuGMGtqE0Uo5rz+53Mz02eNwMz3HxGpdCjoG/g9g1zTIYy6DfXiGfx8Ikz/HceKCGx69v8XNTZMafwDUSGJ9o1kgkCvTeqKlVs33oB3//47lh101vX2F1wnGxibV5e0z37Of3TAzfB3j7TJGRmNgFQfdBzK+Qx/0s75iwpfFl5+2fnhVgfOuFE9/NftPX3wK/cFuGxe/RMzznI6R1TtneMd3vfKR7zgf2nUzPfn7z/PEayOKF+3mfSaSTeCX7HOef2pd+3PucJgFlsWdLyT712dLzyX6Hu/edIY+PFex3QDocWz+plWEcm/8OwDaXBsdV4HMUds/gvXfHtQ/e601IY1nu/3YsY+2CtWn23LIOjeV5/9v6p2xh/VN86p/yD/X/T8dab7zCeUeWyN+S+yU8Pmsv9Tz7sfuOLWkvuJ93rN30zsr653aJf/vVJ8lTH1YW+330n4y1KeR4bLzDZ/36Sa2seYwiR0/U6sPHO9cv/XjHO7xfZb9v+zv2TUl9t+SdkTvX03tuvLbsmTbzw/sb8R3nG59ps/i7x65rz53YGBb03Ildn7z3IPph16d6nm1Bz53SyHFYH9nS5yl1fV78V87f/9fmxf+356X/p/PC/8/Niy/MqyjMzi6xswvLygvtvP/mvPi/XFstyynsn+bFNw2wS/L5/rsMoqVW1tTq+rz4Rk4BdXlefLqzU12cF++2nbqw3gefa1hWWGviE1mZcMwQyk/gPbzlqQse1xuDVLJfks/fyZ7vIFuvjlojss0t0123h/669XDfNWOeELdck7HE3B4hlL9pjUZIz+WzWVtAzbsGAc9Vkscn7+8Tw74Wb7p2gQ8pnmN6fUQb1n6TPX+nevSULbBl7dfdtmnOZcB+3ueXXs07l9oi9m5ZmPeGlVUPtqN9PY9tWOewBfHJ9f1/AGZ8vsD65QEA","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"491":{"source":"use std::hash::blake3;\n\npub fn hash_pair(left: [u8; 32], right: [u8; 32]) -> [u8; 32] {\n    let mut input: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        input[i] = left[i];\n        input[i + 32] = right[i];\n    }\n    blake3(input)\n}\n\npub fn hash_body_fields(\n    verifying_key_data: [u8; 35],\n    connection_info_data: [u8; 17],\n    server_ephemeral_key_data: [u8; 67],\n    cert_commitment_data: [u8; 34],\n    transcript_commitments_data: [u8; 83]\n) -> [[u8; 32]; 5] {\n    let mut body_field_hashes: [[u8; 32]; 5] = [[0; 32]; 5];\n\n    body_field_hashes[0] = hash_field(hash_domain(\"VerifyingKey\".as_bytes()), verifying_key_data);\n    body_field_hashes[1] = hash_field(hash_domain(\"ConnectionInfo\".as_bytes()), connection_info_data);\n    body_field_hashes[2] = hash_field(hash_domain(\"ServerEphemKey\".as_bytes()), server_ephemeral_key_data);\n    body_field_hashes[3] = hash_field(hash_domain(\"ServerCertCommitment\".as_bytes()), cert_commitment_data);\n    body_field_hashes[4] = hash_field(hash_domain(\"TranscriptCommitment\".as_bytes()), transcript_commitments_data);\n\n    body_field_hashes\n}\n\n\npub fn hash_domain<let N: u32>(domain_bytes: [u8; N]) -> [u8; 16] {\n    let domain_hash = blake3(domain_bytes);\n    let mut domain: [u8; 16] = [0; 16];\n    \n    for i in 0..16 {\n        domain[i] = domain_hash[i];\n    }\n    \n    domain\n}\n\npub fn hash_field<let N: u32>(domain: [u8; 16], data: [u8; N]) -> [u8; 32] {\n    let mut input: [u8; 16 + N] = [0; 16 + N]; \n    \n    for i in 0..16 {\n        input[i] = domain[i];\n    }\n    \n    for i in 0..N {\n        input[i + 16] = data[i];\n    }\n    \n    blake3(input)\n}","path":"/home/piotrstec/dev/tlsn-binance/tlsn-presentation-verifier/src/hash.nr"},"492":{"source":"use hash::hash_body_fields;\nuse merkle::{encode_and_hash, compute_header_root, compute_commitment_root};\nuse signature::verify_signature;\nuse chacha_encoder::chacha_encoder::{EncoderSecret};\n\npub mod hash;\npub mod merkle;\npub mod signature;  \n\npub fn main(\n    signature_data: SignatureData,\n    header_verification: HeaderVerification,\n    commitment_verification: CommitmentVerification,\n    transcript_currency: pub TranscriptOpeningCurrency,\n    transcript_comment: pub TranscriptOpeningComment,\n    transcript_amount: pub TranscriptOpeningAmount,\n    transcript_user_name: pub TranscriptOpeningUserName,\n    encoder_secret: EncoderSecret\n) {\n    let message_hash: [u8; 32] = sha256::sha256_var(signature_data.message, 54);\n    let signature_valid = verify_signature(signature_data.key, message_hash, signature_data.signature);\n    assert(signature_valid);\n\n    let body_field_hashes = hash_body_fields(\n        header_verification.verifying_key_data,\n        header_verification.connection_info_data,\n        header_verification.server_ephemeral_key_data,\n        header_verification.cert_commitment_data,\n        header_verification.transcript_commitments_data \n    );\n\n    let computed_header_root = compute_header_root(body_field_hashes);\n    assert(computed_header_root == header_verification.header_root);\n\n    let mut commitment_leaves_hash: [[u8; 32]; 4] = [[0; 32]; 4];\n    \n    // commitment_leaves_hash[0] = encode_and_hash(encoder_secret, transcript_currency.data, transcript_currency.direction, transcript_currency.position, transcript_currency.blinder);\n    // println(commitment_leaves_hash[0]);\n    // commitment_leaves_hash[1] = encode_and_hash(encoder_secret, transcript_comment.data, transcript_comment.direction, transcript_comment.position, transcript_comment.blinder);\n    // println(commitment_leaves_hash[1]);\n    // commitment_leaves_hash[2] = encode_and_hash(encoder_secret, transcript_amount.data, transcript_amount.direction, transcript_amount.position, transcript_amount.blinder);\n    // println(commitment_leaves_hash[2]);\n    // commitment_leaves_hash[3] = encode_and_hash(encoder_secret, transcript_user_name.data, transcript_user_name.direction, transcript_user_name.position, transcript_user_name.blinder);\n    // println(commitment_leaves_hash[3]);\n\n    // let computed_commitment_root = compute_commitment_root(commitment_leaves_hash);\n    // assert(computed_commitment_root == commitment_verification.commitment_root);\n}\n\npub struct TranscriptOpeningAmount {\n    direction: u8,\n    data: [u8; 11],\n    blinder: [u8; 16],\n    position: u32,\n}\n\npub struct TranscriptOpeningUserName {\n    direction: u8,\n    data: [u8; 23],\n    blinder: [u8; 16],\n    position: u32,\n}\n\npub struct TranscriptOpeningComment {\n    direction: u8,\n    data: [u8; 23],\n    blinder: [u8; 16],\n    position: u32,  \n}\n\npub struct TranscriptOpeningCurrency {\n    direction: u8,\n    data: [u8; 16],\n    blinder: [u8; 16],\n    position: u32,\n}\n\npub struct SignatureData {\n    key: [u8; 64],\n    message: [u8; 54],\n    signature: [u8; 64],\n}\n\npub struct HeaderVerification {\n    header_root: [u8; 32],\n    verifying_key_data: [u8; 35],\n    connection_info_data: [u8; 17],\n    server_ephemeral_key_data: [u8; 67],\n    cert_commitment_data: [u8; 34],\n    transcript_commitments_data: [u8; 83],\n}\n\npub struct CommitmentVerification {\n    commitment_root: [u8; 32],\n}\n\n","path":"/home/piotrstec/dev/tlsn-binance/tlsn-presentation-verifier/src/main.nr"},"493":{"source":"use super::hash::hash_pair;\nuse chacha_encoder::chacha_encoder::{add_sixteen_elements, encode_data_generic_byte, EncoderSecret};\nuse std::hash::blake3;\n\npub fn compute_commitment_root(leaves: [[u8; 32]; 4]) -> [u8; 32] {\n    // Level 1\n    let h0 = hash_pair(leaves[0], leaves[1]);\n    let h1 = hash_pair(leaves[2], leaves[3]);\n    \n    // Root\n    let root = hash_pair(h0, h1);\n\n    root\n}\n\npub fn compute_header_root(leaves: [[u8; 32]; 5]) -> [u8; 32] {\n    // Level 1\n    let h0 = hash_pair(leaves[0], leaves[1]);\n    let h1 = hash_pair(leaves[2], leaves[3]);\n    let h2 = leaves[4];\n\n    // Level 2\n    let h3 = hash_pair(h0, h1);\n\n    // Root\n    let root = hash_pair(h3, h2);\n\n    root\n}\n\npub fn encode_and_hash<let N: u32>(encoder_secret: EncoderSecret, data: [u8; N], direction: u8, position: u32, blinder: [u8; 16]) -> [u8; 32] {\n    let encoded_data = encode_data_generic_byte(encoder_secret, direction ,position, data);\n\n    let encoded_with_blinder = add_sixteen_elements\n    (encoded_data, blinder);\n\n    let hash = blake3(encoded_with_blinder);\n    hash\n}\n","path":"/home/piotrstec/dev/tlsn-binance/tlsn-presentation-verifier/src/merkle.nr"},"494":{"source":"pub fn verify_signature(key: [u8; 64], message_hash: [u8; 32], signature: [u8; 64]) -> bool {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = key[i];\n        pub_key_y[i] = key[i + 32];\n    }\n\n    let is_valid =\n        std::ecdsa_secp256k1::verify_signature(pub_key_x, pub_key_y, signature, message_hash);\n\n    is_valid\n}","path":"/home/piotrstec/dev/tlsn-binance/tlsn-presentation-verifier/src/signature.nr"},"504":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let int_input = (block_input + INT_SIZE - 1) / INT_SIZE;\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\n#[inline_always]\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    msg_block[INT_SIZE_PTR] = (len_bytes[0] as u32) << 24\n        | (len_bytes[1] as u32) << 16\n        | (len_bytes[2] as u32) << 8\n        | (len_bytes[3] as u32);\n\n    msg_block[INT_SIZE_PTR + 1] = (len_bytes[4] as u32) << 24\n        | (len_bytes[5] as u32) << 16\n        | (len_bytes[6] as u32) << 8\n        | (len_bytes[7] as u32);\n\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n","path":"/home/piotrstec/nargo/github.com/noir-lang/sha256/v0.1.4/src/sha256.nr"}},"names":["main"],"brillig_names":["build_msg_block","attach_len_to_msg_block","directive_integer_quotient","directive_to_radix"]}