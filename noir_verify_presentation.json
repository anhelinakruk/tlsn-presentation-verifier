{"noir_version":"1.0.0-beta.8+ba05d729b9753aa5ce2b076c1dd4795edb173f68","hash":"8530619862001260565","abi":{"parameters":[{"name":"key","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"message","type":{"kind":"array","length":54,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"header_root","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"verifying_key_data","type":{"kind":"array","length":35,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"connection_info_data","type":{"kind":"array","length":17,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"server_ephemeral_key_data","type":{"kind":"array","length":67,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"cert_commitment_data","type":{"kind":"array","length":34,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"transcript_commitments_data","type":{"kind":"array","length":83,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"commitment_root","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"transcript_mins","type":{"kind":"struct","path":"TranscriptOpeningMins","fields":[{"name":"direction","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"data","type":{"kind":"array","length":8,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"blinders","type":{"kind":"array","length":16,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"position","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"public"},{"name":"transcript_close_time","type":{"kind":"struct","path":"TranscriptOpeningCloseTime","fields":[{"name":"direction","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"data","type":{"kind":"array","length":25,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"blinders","type":{"kind":"array","length":16,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"position","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"public"},{"name":"transcript_price","type":{"kind":"struct","path":"TranscriptOpeningPrice","fields":[{"name":"direction","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"data","type":{"kind":"array","length":20,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"blinders","type":{"kind":"array","length":16,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"position","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"public"},{"name":"transcript_symbol","type":{"kind":"struct","path":"TranscriptOpeningSymbol","fields":[{"name":"direction","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"data","type":{"kind":"array","length":14,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"blinders","type":{"kind":"array","length":16,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"position","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"public"},{"name":"encoder_secret","type":{"kind":"struct","path":"chacha_encoder::chacha_encoder::EncoderSecret","fields":[{"name":"seed","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"delta","type":{"kind":"array","length":16,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},"visibility":"private"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6668324276689745315":{"error_kind":"string","string":"Field failed to decompose into specified 4 limbs"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"9311":{"source":"use std::hash::blake3;\n\npub fn hash_pair(left: [u8; 32], right: [u8; 32]) -> [u8; 32] {\n    let mut input: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        input[i] = left[i];\n        input[i + 32] = right[i];\n    }\n    blake3(input)\n}\n\npub fn hash_pair_sha256(left: [u8; 32], right: [u8; 32]) -> [u8; 32] {\n    let mut input: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        input[i] = left[i];\n        input[i + 32] = right[i];\n    }\n    sha256::sha256_var(input, input.len() as u64)\n}\n\npub fn hash_body_fields(\n    verifying_key_data: [u8; 35],\n    connection_info_data: [u8; 17],\n    server_ephemeral_key_data: [u8; 67],\n    cert_commitment_data: [u8; 34],\n    transcript_commitments_data: [u8; 83],\n) -> [[u8; 32]; 5] {\n    let mut body_field_hashes: [[u8; 32]; 5] = [[0; 32]; 5];\n\n    body_field_hashes[0] = hash_field(hash_domain(\"VerifyingKey\".as_bytes()), verifying_key_data);\n    body_field_hashes[1] = hash_field(\n        hash_domain(\"ConnectionInfo\".as_bytes()),\n        connection_info_data,\n    );\n    body_field_hashes[2] = hash_field(\n        hash_domain(\"ServerEphemKey\".as_bytes()),\n        server_ephemeral_key_data,\n    );\n    body_field_hashes[3] = hash_field(\n        hash_domain(\"ServerCertCommitment\".as_bytes()),\n        cert_commitment_data,\n    );\n    body_field_hashes[4] = hash_field(\n        hash_domain(\"TranscriptCommitment\".as_bytes()),\n        transcript_commitments_data,\n    );\n\n    body_field_hashes\n}\n\npub fn hash_domain<let N: u32>(domain_bytes: [u8; N]) -> [u8; 16] {\n    let domain_hash = blake3(domain_bytes);\n    let mut domain: [u8; 16] = [0; 16];\n\n    for i in 0..16 {\n        domain[i] = domain_hash[i];\n    }\n\n    domain\n}\n\npub fn hash_field<let N: u32>(domain: [u8; 16], data: [u8; N]) -> [u8; 32] {\n    let mut input: [u8; 16 + N] = [0; 16 + N];\n\n    for i in 0..16 {\n        input[i] = domain[i];\n    }\n\n    for i in 0..N {\n        input[i + 16] = data[i];\n    }\n\n    blake3(input)\n}\n","path":"/home/piotrstec/dev/tlsn-binance/tlsn-presentation-verifier/src/hash.nr"},"9312":{"source":"use chacha_encoder::chacha_encoder::EncoderSecret;\nuse hash::hash_body_fields;\nuse merkle::{compute_commitment_root, compute_header_root, encode_and_hash};\nuse signature::verify_signature;\n\npub mod hash;\npub mod merkle;\npub mod signature;\n\nfn main(\n    key: [u8; 64],\n    message: [u8; 54],\n    signature: [u8; 64],\n    header_root: [u8; 32],\n    verifying_key_data: [u8; 35],\n    connection_info_data: [u8; 17],\n    server_ephemeral_key_data: [u8; 67],\n    cert_commitment_data: [u8; 34],\n    transcript_commitments_data: [u8; 83],\n    commitment_root: [u8; 32],\n    transcript_mins: pub TranscriptOpeningMins,\n    transcript_close_time: pub TranscriptOpeningCloseTime,\n    transcript_price: pub TranscriptOpeningPrice,\n    transcript_symbol: pub TranscriptOpeningSymbol,\n    encoder_secret: EncoderSecret,\n) {\n    let message_hash: [u8; 32] = sha256::sha256_var(message, 54);\n    let signature_valid = verify_signature(key, message_hash, signature);\n    assert(signature_valid);\n\n    let body_field_hashes = hash_body_fields(\n        verifying_key_data,\n        connection_info_data,\n        server_ephemeral_key_data,\n        cert_commitment_data,\n        transcript_commitments_data,\n    );\n\n    let computed_header_root = compute_header_root(body_field_hashes);\n    assert(computed_header_root == header_root);\n\n    let mut commitment_leaves_hash: [[u8; 32]; 4] = [[0; 32]; 4];\n\n    // commitment_leaves_hash[0] = encode_and_hash(\n    //     encoder_secret,\n    //     transcript_mins.data,\n    //     transcript_mins.direction,\n    //     transcript_mins.position,\n    //     transcript_mins.blinders,\n    // );\n    // println(commitment_leaves_hash[0]);\n    // commitment_leaves_hash[1] = encode_and_hash(\n    //     encoder_secret,\n    //     transcript_close_time.data,\n    //     transcript_close_time.direction,\n    //     transcript_close_time.position,\n    //     transcript_close_time.blinders,\n    // );\n    // println(commitment_leaves_hash[1]);\n    // commitment_leaves_hash[2] = encode_and_hash(\n    //     encoder_secret,\n    //     transcript_price.data,\n    //     transcript_price.direction,\n    //     transcript_price.position,\n    //     transcript_price.blinders,\n    // );\n    // println(commitment_leaves_hash[2]);\n\n    // commitment_leaves_hash[3] = encode_and_hash(\n    //     encoder_secret,\n    //     transcript_symbol.data,\n    //     transcript_symbol.direction,\n    //     transcript_symbol.position,\n    //     transcript_symbol.blinders,\n    // );\n    // println(commitment_leaves_hash[3]);\n\n    // let computed_commitment_root = compute_commitment_root(commitment_leaves_hash);\n    // assert(computed_commitment_root == commitment_root);\n}\n\npub struct TranscriptOpeningMins {\n    direction: u8,\n    data: [u8; 8],\n    blinders: [u8; 16],\n    position: u32,\n}\n\npub struct TranscriptOpeningCloseTime {\n    direction: u8,\n    data: [u8; 25],\n    blinders: [u8; 16],\n    position: u32,\n}\n\npub struct TranscriptOpeningPrice {\n    direction: u8,\n    data: [u8; 20],\n    blinders: [u8; 16],\n    position: u32,\n}\n\npub struct TranscriptOpeningSymbol {\n    direction: u8,\n    data: [u8; 14],\n    blinders: [u8; 16],\n    position: u32,\n}\n","path":"/home/piotrstec/dev/tlsn-binance/tlsn-presentation-verifier/src/main.nr"},"9313":{"source":"use super::hash::{hash_pair, hash_pair_sha256};\nuse chacha_encoder::chacha_encoder::{encode_data_generic_byte, EncoderSecret};\n\npub fn compute_commitment_root(leaves: [[u8; 32]; 4]) -> [u8; 32] {\n    // Level 1\n    let h0 = hash_pair_sha256(leaves[0], leaves[1]);\n    let h1 = hash_pair_sha256(leaves[2], leaves[3]);\n    // Root\n    let root = hash_pair_sha256(h0, h1);\n\n    root\n}\n\npub fn compute_header_root(leaves: [[u8; 32]; 5]) -> [u8; 32] {\n    // Level 1\n    let h0 = hash_pair(leaves[0], leaves[1]);\n    let h1 = hash_pair(leaves[2], leaves[3]);\n    let h2 = leaves[4];\n\n    // Level 2\n    let h3 = hash_pair(h0, h1);\n\n    // Root\n    let root = hash_pair(h3, h2);\n\n    root\n}\n\npub fn encode_and_hash<let N: u32>(\n    encoder_secret: EncoderSecret,\n    data: [u8; N],\n    direction: u8,\n    position: u32,\n    blinder: [u8; 16],\n) -> [u8; 32] {\n    let encoded_data = encode_data_generic_byte(encoder_secret, direction, position, data);\n\n    let encoded_with_blinder = add_sixteen_elements(encoded_data, blinder);\n\n    let hash = sha256::sha256_var(encoded_with_blinder, encoded_with_blinder.len() as u64);\n    hash\n}\n\npub fn add_sixteen_elements<let INPUT_SIZE: u32>(\n    input: [u8; INPUT_SIZE],\n    additional_elements: [u8; 16],\n) -> [u8; INPUT_SIZE + 16] {\n    // Verify that OUTPUT_SIZE = INPUT_SIZE + 16\n\n    let mut result = [0; INPUT_SIZE + 16];\n\n    // Copy original data\n    for i in 0..INPUT_SIZE {\n        result[i] = input[i];\n    }\n\n    // Add the 16 additional elements at the end\n    for i in 0..16 {\n        result[INPUT_SIZE + i] = additional_elements[i];\n    }\n\n    result\n}\n","path":"/home/piotrstec/dev/tlsn-binance/tlsn-presentation-verifier/src/merkle.nr"},"9314":{"source":"pub fn verify_signature(key: [u8; 64], message_hash: [u8; 32], signature: [u8; 64]) -> bool {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = key[i];\n        pub_key_y[i] = key[i + 32];\n    }\n\n    let is_valid =\n        std::ecdsa_secp256k1::verify_signature(pub_key_x, pub_key_y, signature, message_hash);\n\n    is_valid\n}","path":"/home/piotrstec/dev/tlsn-binance/tlsn-presentation-verifier/src/signature.nr"},"9325":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let int_input = (block_input + INT_SIZE - 1) / INT_SIZE;\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\n#[inline_always]\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    msg_block[INT_SIZE_PTR] = (len_bytes[0] as u32) << 24\n        | (len_bytes[1] as u32) << 16\n        | (len_bytes[2] as u32) << 8\n        | (len_bytes[3] as u32);\n\n    msg_block[INT_SIZE_PTR + 1] = (len_bytes[4] as u32) << 24\n        | (len_bytes[5] as u32) << 16\n        | (len_bytes[6] as u32) << 8\n        | (len_bytes[7] as u32);\n\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n","path":"/home/piotrstec/nargo/github.com/noir-lang/sha256/v0.1.4/src/sha256.nr"}},"names":["main"],"brillig_names":["build_msg_block","attach_len_to_msg_block","directive_integer_quotient","directive_to_radix"]}